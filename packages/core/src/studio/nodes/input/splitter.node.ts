import {
  type Context,
  type ContextLike,
  isContextLike,
} from '../../../events/input/load/docs/index.js';
import {
  type ContextSplitter,
  RecursiveTextSplitter,
  SupportedLanguageForSplit,
  TextSplitter,
  TokenTextSplitter,
} from '../../../events/input/transform/index.js';
import { load } from '../../../load/index.js';
import {
  globalImportMap,
  globalSecretMap,
} from '../../../load/registration.js';
import { type CallableConfig } from '../../../record/index.js';
import { getRecordId } from '../../../utils/nanoid.js';
import { type Data, scalarDefaults } from '../../data.js';
import {
  type ProcessInputMap,
  type ProcessContext,
  type ProcessOutputMap,
} from '../../processor.js';
import { type SerializedNode } from '../../serde.js';
import { coerceToData } from '../../utils/coerce.js';
import { CallableNodeImpl } from '../base.js';
import { type CallableNode } from '../index.js';

/**
 * A type alias for a specialized callable node focused on splitting operations.
 * This node type is specialized for handling the splitting of data into multiple contexts,
 * particularly in scenarios where input data needs to be divided into manageable pieces.
 */
export type SplitterNode = CallableNode<'splitter', ContextSplitter>;

/**
 * An abstract class providing a base implementation for splitter nodes.
 * This class extends the callable node implementation to provide specialized
 * functionalities for data splitting.
 */
export abstract class SplitterNodeImpl extends CallableNodeImpl<SplitterNode> {
  /**
   * Deserializes a serialized splitter node representation into an executable splitter node,
   * reconstituting the node with its operational parameters and data.
   *
   * @param serialized The serialized node data.
   * @returns A promise resolving to a deserialized splitter node.
   */
  static async deserialize(serialized: SerializedNode): Promise<SplitterNode> {
    const subType: string = serialized.subType;

    switch (subType) {
      case 'text':
        return TextSplitterNodeImpl.deserialize(serialized);
      case 'paragraph':
        return RecursiveTextSplitterNodeImpl.deserialize(serialized);
      case 'cpp': 
      case 'go': 
      case 'java': 
      case 'js': 
      case 'php': 
      case 'proto': 
      case 'python': 
      case 'rst': 
      case 'ruby': 
      case 'rust': 
      case 'scala': 
      case 'swift': 
      case 'markdown': 
      case 'latex': 
      case 'html': 
      case 'sol':
        return LanguageTextSplitterNodeImpl.deserialize(serialized);
      case 'token':
        return TokenTextSplitterNodeImpl.deserialize(serialized);
      default:
        throw new Error('Plugin node is unsupported for now');
    }
  }

  /**
   * Preprocesses the input data to ensure it is in a valid format for splitting.
   * This step ensures that the input data is a string, a single context, or an array of contexts.
   *
   * @param inputs The map containing input data for the node.
   * @param context The processing context, not actively used here.
   * @returns The validated and cast input data as ContextLike.
   * @throws Error if the inputs are not valid.
   * @internal
   */
  protected async _preprocess(
    inputs: ProcessInputMap,
    context: ProcessContext
  ): Promise<ContextLike> {
    const input: Data | undefined = inputs['input'];

    if (
      !input ||
      !(
        input.type === 'string' ||
        input.type === 'context' ||
        input.type === 'context[]'
      )
    ) {
      throw new Error(
        `${this.type} Node ${this.title} failed in preprocess because of invalid inputs.`
      );
    }

    return input.value;
  }

  /**
   * Postprocesses the raw output from the splitter, wrapping it into the expected output format.
   *
   * @param rawOutputs The raw contexts generated by the splitter.
   * @param context The processing context, not actively used here.
   * @returns A map of process outputs keyed by their output port names.
   * @internal
   */
  protected async _postprocess(
    rawOutputs: Context[],
    context: ProcessContext
  ): Promise<ProcessOutputMap> {
    const contexts = coerceToData(rawOutputs);

    return { contexts };
  }

  /**
   * Invokes the splitter with the given input under the provided options.
   * This method directly interfaces with the splitter's callable mechanism.
   *
   * @param input The input data for the splitter, expected to be ContextLike.
   * @param options Optional additional settings for the splitter call.
   * @returns The output from the splitter as specified by the splitter's output type.
   */
  async invoke<CallInput, CallOutput, CallOptions>(
    input: CallInput,
    options?: Partial<CallOptions>
  ): Promise<CallOutput> {
    if (!isContextLike(input)) {
      throw new Error(
        `${this.type} Node ${this.title} failed in preprocess because of invalid inputs.`
      );
    }

    return this.data.invoke(input, options) as CallOutput;
  }

  /**
   * Main process method that orchestrates the full lifecycle of data splitting.
   * This method integrates input validation, preprocessing, splitter invocation, and
   * postprocessing.
   *
   * @param inputs A map containing all inputs to the node.
   * @param context The current processing context.
   * @returns A map of outputs as processed by the node.
   * @throws Error if inputs are not valid or if any stage of processing fails.
   */
  async process(
    inputs: ProcessInputMap,
    context: ProcessContext
  ): Promise<ProcessOutputMap> {
    if (!this.validateInputs(inputs)) {
      throw new Error(`${this.type} Node ${this.title} has invalid inputs`);
    }

    const rawInputs: ContextLike = await this._preprocess(inputs, context);

    const rawOutputs: Context[] = await this.invoke<
      ContextLike,
      Context[],
      CallableConfig
    >(rawInputs);

    return this._postprocess(rawOutputs, context);
  }
}

/**
 * Implementation of a SplitterNode specifically for splitting text data.
 * This node handles the segmentation of text data into discrete contexts, which can be used
 * for further processing.
 *
 * ### Node Properties
 *
 * | Field       | Type                | Description                                                                   |
 * |-------------|---------------------|-------------------------------------------------------------------------------|
 * | `type`      | `'splitter'`        | The type of the node, indicating it handles splitting operations.             |
 * | `subtype`   | `'text'`            | The subtype of the node, specifying that it is specialized for text data.      |
 * | `data`      | {@link TextSplitter}| The callable used for text splitting operations.                               |
 *
 * ### Input Ports
 *
 * | Port Name   | Supported Types     | Description                                                                 |
 * |-------------|---------------------|-----------------------------------------------------------------------------|
 * | `input`     | `string`, `context`, `context[]` | Accepts text data as a string, a context, or an array of contexts for splitting. |
 *
 * ### Output Ports
 *
 * | Port Name   | Supported Types     | Description                                                                 |
 * |-------------|---------------------|-----------------------------------------------------------------------------|
 * | `contexts`  | `context[]`         | Outputs an array of contexts derived from the split text data.              |
 *
 */
export class TextSplitterNodeImpl extends SplitterNodeImpl {
  /**
   * Creates a SplitterNode configuration from a TextSplitter callable instance.
   * @param callable An instance of TextSplitter defining the splitting logic.
   * @returns A fully configured SplitterNode specialized for text operations.
   */
  static nodeFrom(callable: TextSplitter): SplitterNode {
    return {
      id: getRecordId(),
      type: 'splitter',
      subType: 'text',
      data: callable,
      visualInfo: {
        position: {
          x: 0,
          y: 0,
        },
        size: {
          width: 300,
          height: 500,
        },
      },
      inputs: {
        input: ['string', 'context', 'context[]'],
      },
      outputs: {
        contexts: 'context[]',
      },
    };
  }

  /**
   * Factory method to create a new instance of TextSplitterNode.
   * This method provides a simple way to instantiate a text splitter node with default settings
   * for splitting text data into multiple contexts.
   *
   * @returns An instance of SplitterNode prepared with a default TextSplitter.
   */
  static create(): SplitterNode {
    const textSplitter = new TextSplitter(scalarDefaults['object']);

    const node: SplitterNode = TextSplitterNodeImpl.nodeFrom(textSplitter);

    return node;
  }

  static async deserialize(serialized: SerializedNode): Promise<SplitterNode> {
    const {
      id,
      type,
      subType,
      registerArgs,
      data,
      visualInfo,
      inputs,
      outputs,
      runtime,
      memory,
      outputSizes,
    } = serialized;

    if (type !== 'splitter') {
      throw new Error(`CANNOT deserialize this type in splitter node: ${type}`);
    }

    const splitterStr = JSON.stringify(data);
    const splitter = await load<TextSplitter>(
      splitterStr,
      globalSecretMap,
      globalImportMap
    );

    return {
      id,
      type,
      subType,
      registerArgs,
      data: splitter,
      visualInfo,
      inputs,
      outputs,
      runtime,
      memory,
      outputSizes,
    };
  }
}

/**
 * Implementation of a SplitterNode specifically for recursively splitting text data.
 * This node handles the deep segmentation of text data into discrete contexts, which can be used for further processing.
 * It supports customizable splitting strategies based on different languages.
 *
 * ### Node Properties
 *
 * | Field           | Type                       | Description                                                                   |
 * |-----------------|----------------------------|-------------------------------------------------------------------------------|
 * | `type`          | `'splitter'`               | The type of the node, indicating it handles splitting operations.             |
 * | `subType`       | {@link SupportedLanguageForSplit} or `'paragraph'` | The subtype of the node, specifying the language or defaulting to 'paragraph' for text data. |
 * | `registerArgs`  | `{ language: '<supported-language>' }` | Optional arguments specifying the language used for splitting.             |
 * | `data`          | {@link RecursiveTextSplitter} | The callable used for recursive text splitting operations.                  |
 *
 * ### Input Ports
 *
 * | Port Name   | Supported Types     | Description                                                                 |
 * |-------------|---------------------|-----------------------------------------------------------------------------|
 * | `input`     | `string`, `context`, `context[]` | Accepts text data as a string, a context, or an array of contexts for recursive splitting. |
 *
 * ### Output Ports
 *
 * | Port Name   | Supported Types     | Description                                                                 |
 * |-------------|---------------------|-----------------------------------------------------------------------------|
 * | `contexts`  | `context[]`         | Outputs an array of contexts derived from the recursively split text data.  |
 *
 */
export class RecursiveTextSplitterNodeImpl extends SplitterNodeImpl {
  /**
   * Creates a SplitterNode configuration from a RecursiveTextSplitter callable instance.
   * @param callable A instance of RecursiveTextSplitter defining the recursive splitting logic.
   * @param registerArgs Optional parameters to specify the language used for splitting, influencing the splitting strategy.
   * @returns A fully configured SplitterNode specialized for recursive text operations.
   */
  static nodeFrom(
    callable: RecursiveTextSplitter,
    registerArgs?: { language: SupportedLanguageForSplit }
  ): SplitterNode {
    return {
      id: getRecordId(),
      type: 'splitter',
      subType: registerArgs ? registerArgs.language : 'paragraph',
      registerArgs,
      data: callable,
      visualInfo: {
        position: {
          x: 0,
          y: 0,
        },
        size: {
          width: 300,
          height: 500,
        },
      },
      inputs: {
        input: ['string', 'context', 'context[]'],
      },
      outputs: {
        contexts: 'context[]',
      },
    };
  }

  /**
   * Factory method to create a new instance of RecursiveTextSplitterNode.
   * This method provides a simple way to instantiate a recursive text splitter node with default settings
   * and an unspecified language, defaulting to paragraph-based splitting.
   * Additional configuration for language-specific splitting can be specified via the nodeFrom method.
   *
   * @returns An instance of SplitterNode prepared with a default RecursiveTextSplitter.
   */
  static create(): SplitterNode {
    const textSplitter = new RecursiveTextSplitter(scalarDefaults['object']);

    const node: SplitterNode =
      RecursiveTextSplitterNodeImpl.nodeFrom(textSplitter);

    return node;
  }

  static async deserialize(serialized: SerializedNode): Promise<SplitterNode> {
    const {
      id,
      type,
      subType,
      registerArgs,
      data,
      visualInfo,
      inputs,
      outputs,
      runtime,
      memory,
      outputSizes,
    } = serialized;

    if (type !== 'splitter') {
      throw new Error(`CANNOT deserialize this type in splitter node: ${type}`);
    }

    const splitterStr = JSON.stringify(data);
    const splitter = await load<RecursiveTextSplitter>(
      splitterStr,
      globalSecretMap,
      globalImportMap
    );

    return {
      id,
      type,
      subType,
      registerArgs,
      data: splitter,
      visualInfo,
      inputs,
      outputs,
      runtime,
      memory,
      outputSizes,
    };
  }
}

/**
 * Implementation of a SplitterNode specifically designed for language-sensitive text splitting.
 * This node utilizes a recursive text splitting strategy tailored to the specific nuances of a given language,
 * making it ideal for applications requiring linguistic awareness in text segmentation.
 *
 * ### Node Properties
 *
 * | Field           | Type                         | Description                                                                   |
 * |-----------------|------------------------------|-------------------------------------------------------------------------------|
 * | `type`          | `'splitter'`                 | The type of the node, indicating it handles text splitting operations.        |
 * | `subType`       | {@link SupportedLanguageForSplit}  | The subtype of the node, specifying the language used for text splitting.    |
 * | `registerArgs`  | `{ language: '<supported-language>' }` | Parameters specifying the language used for splitting, influencing the strategy. |
 * | `data`          | {@link RecursiveTextSplitter} | The callable used for recursive, language-specific text splitting operations.|
 *
 * ### Input Ports
 *
 * | Port Name   | Supported Types             | Description                                                                 |
 * |-------------|-----------------------------|-----------------------------------------------------------------------------|
 * | `input`     | `string`, `context`, `context[]` | Accepts text data as a string, a context, or an array of contexts for splitting. |
 *
 * ### Output Ports
 *
 * | Port Name   | Supported Types             | Description                                                                 |
 * |-------------|-----------------------------|-----------------------------------------------------------------------------|
 * | `contexts`  | `context[]`                 | Outputs an array of contexts derived from the language-specific split text data.  |
 *
 */
export class LanguageTextSplitterNodeImpl extends SplitterNodeImpl {
  /**
   * Creates a SplitterNode configuration from a RecursiveTextSplitter callable instance,
   * with specific settings for language-based text splitting.
   * @param callable A instance of RecursiveTextSplitter defining the recursive splitting logic.
   * @param registerArgs Parameters to specify the language used for splitting, crucial for adapting the splitting strategy.
   * @returns A fully configured SplitterNode specialized for language-specific text operations.
   */
  static nodeFrom(
    callable: RecursiveTextSplitter,
    registerArgs: { language: SupportedLanguageForSplit }
  ): SplitterNode {
    return {
      id: getRecordId(),
      type: 'splitter',
      subType: registerArgs.language,
      registerArgs,
      data: callable,
      visualInfo: {
        position: {
          x: 0,
          y: 0,
        },
        size: {
          width: 300,
          height: 500,
        },
      },
      inputs: {
        input: ['string', 'context', 'context[]'],
      },
      outputs: {
        contexts: 'context[]',
      },
    };
  }

  /**
   * Factory method to create a new instance of LanguageTextSplitterNode.
   * This method initializes a new node with a RecursiveTextSplitter instance configured
   * for a specific language, providing a tailored approach to text splitting based on linguistic requirements.
   * This method allows for language-specific configurations to be defined at the point of node creation.
   *
   * @param fields Parameters including the language setting for the splitter, dictating the node's specialization.
   * @returns An instance of SplitterNode prepared with a language-tailored RecursiveTextSplitter.
   */
  static create(fields: { language: SupportedLanguageForSplit }): SplitterNode {
    const textSplitter = RecursiveTextSplitter.fromLanguage(fields.language);

    const node: SplitterNode = LanguageTextSplitterNodeImpl.nodeFrom(
      textSplitter,
      fields
    );

    return node;
  }

  /**
   * Deserializes a serialized splitter node representation into an executable splitter node,
   * reconstituting the node with its operational parameters and data.
   *
   * @param serialized The serialized node data.
   * @returns A promise resolving to a deserialized splitter node.
   */
  static async deserialize(serialized: SerializedNode): Promise<SplitterNode> {
    const {
      id,
      type,
      subType,
      registerArgs,
      data,
      visualInfo,
      inputs,
      outputs,
      runtime,
      memory,
      outputSizes,
    } = serialized;

    if (type !== 'splitter') {
      throw new Error(`CANNOT deserialize this type in splitter node: ${type}`);
    }

    const splitterStr = JSON.stringify(data);
    const splitter = await load<RecursiveTextSplitter>(
      splitterStr,
      globalSecretMap,
      globalImportMap
    );

    return {
      id,
      type,
      subType,
      registerArgs,
      data: splitter,
      visualInfo,
      inputs,
      outputs,
      runtime,
      memory,
      outputSizes,
    };
  }
}

/**
 * Implementation of a SplitterNode specifically designed for token-based text splitting.
 * This node utilizes a tokenization strategy to segment text data into discrete tokens,
 * which are smaller pieces such as words or punctuation, suitable for further text analysis and processing.
 *
 * ### Node Properties
 *
 * | Field       | Type                  | Description                                                                   |
 * |-------------|-----------------------|-------------------------------------------------------------------------------|
 * | `type`      | `'splitter'`          | The type of the node, indicating it handles text splitting operations.        |
 * | `subType`   | `'token'`             | The subtype of the node, specifying that it is specialized for token-based splitting. |
 * | `data`      | {@link TokenTextSplitter} | The callable used for token-based text splitting operations.                 |
 *
 * ### Input Ports
 *
 * | Port Name   | Supported Types     | Description                                                                 |
 * |-------------|---------------------|-----------------------------------------------------------------------------|
 * | `input`     | `string`, `context`, `context[]` | Accepts text data as a string, a context, or an array of contexts for tokenization. |
 *
 * ### Output Ports
 *
 * | Port Name   | Supported Types     | Description                                                                 |
 * |-------------|---------------------|-----------------------------------------------------------------------------|
 * | `contexts`  | `context[]`         | Outputs an array of contexts derived from the tokenized text data.          |
 *
 */
export class TokenTextSplitterNodeImpl extends SplitterNodeImpl {
  /**
   * Creates a SplitterNode configuration from a TokenTextSplitter callable instance.
   * @param callable An instance of TokenTextSplitter defining the token splitting logic.
   * @returns A fully configured SplitterNode specialized for token operations.
   */
  static nodeFrom(callable: TokenTextSplitter): SplitterNode {
    return {
      id: getRecordId(),
      type: 'splitter',
      subType: 'token',
      data: callable,
      visualInfo: {
        position: {
          x: 0,
          y: 0,
        },
        size: {
          width: 300,
          height: 500,
        },
      },
      inputs: {
        input: ['string', 'context', 'context[]'],
      },
      outputs: {
        contexts: 'context[]',
      },
    };
  }

  /**
   * Factory method to create a new instance of TokenTextSplitterNode.
   * This method provides a simple way to instantiate a token splitter node with default settings
   * for breaking down text into manageable tokens, facilitating tasks such as linguistic analysis or further processing.
   *
   * @returns An instance of SplitterNode prepared with a default TokenTextSplitter.
   */
  static create(): SplitterNode {
    const tokenSplitter = new TokenTextSplitter(scalarDefaults['object']);

    const node: SplitterNode =
      TokenTextSplitterNodeImpl.nodeFrom(tokenSplitter);

    return node;
  }

  /**
   * Deserializes a serialized splitter node representation into an executable splitter node,
   * reconstituting the node with its operational parameters and data.
   *
   * @param serialized The serialized node data.
   * @returns A promise resolving to a deserialized splitter node.
   */
  static async deserialize(serialized: SerializedNode): Promise<SplitterNode> {
    const {
      id,
      type,
      subType,
      registerArgs,
      data,
      visualInfo,
      inputs,
      outputs,
      runtime,
      memory,
      outputSizes,
    } = serialized;

    if (type !== 'splitter') {
      throw new Error(`CANNOT deserialize this type in splitter node: ${type}`);
    }

    const splitterStr = JSON.stringify(data);
    const splitter = await load<TokenTextSplitter>(
      splitterStr,
      globalSecretMap,
      globalImportMap
    );

    return {
      id,
      type,
      subType,
      registerArgs,
      data: splitter,
      visualInfo,
      inputs,
      outputs,
      runtime,
      memory,
      outputSizes,
    };
  }
}
