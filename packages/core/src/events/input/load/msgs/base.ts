import {
  Serializable,
  type SerializedConstructor,
} from '../../../../load/serializable.js';
import { isDeepEqual } from '../../../../utils/equal.js';
import {
  type SerializedMessage,
  type SerializedMessageData,
} from '../../../output/provide/serde.js';

/**
 * Represents the role of a message within a system, which helps in identifying the purpose and the origin of the message.
 * This role can influence how the message is processed or displayed in various parts of the system.
 */
export type MessageRole =
  | 'human' // Represents messages originating from human users.
  | 'assistant' // Represents messages generated by an automated assistant (e.g. LLMs).
  | 'system' // Represents prompt messages for LLMs.
  | 'function' // Represents messages that are the configuration of specific functions for function-calling/tool-calling in LLMs.
  | 'general'; // Represents general messages that do not fit into the predefined categories.

/**
 * Defines the structure of a typical message within the system, incorporating content and optional metadata such as role and name.
 */
export type Message = {
  /**
   * The main textual content of the message.
   */
  content: string;

  /**
   * Optional role of the message, which helps categorize the message's origin or purpose within the system.
   */
  role?: MessageRole;

  /**
   * An optional name associated with the message, which could be used for more specific identification or referencing purposes.
   */
  name?: string;
};

/**
 * Represents a flexible representation of a message, which can be either a complete BaseMessage instance, a tuple of role and string content,
 * or a simple string. This type is useful for functions that need to accept messages in various formats.
 */
export type BaseMessageLike = BaseMessage | [MessageRole, string] | string;

/**
 * Represents the types of content that can be used in messages. This type is designed to be flexible, 
 * allowing either a simple string or an object with key-value pairs, which can represent more structured data.
 */
export type ContentLike = string | { [key: string]: unknown };

/**
 * Defines the structure for the basic fields of a message within the system.
 * This interface includes the primary content of the message, an optional name,
 * and additional keyword arguments that might be used for further customization or processing.
 */
export interface BaseMessageFields {
  /**
   * The main content of the message. It can be a string or a more complex structure
   * represented by an object with key-value pairs.
   */
  content: ContentLike | ContentLike[];

  /**
   * An optional name for the message, which could be used for identifying or categorizing the message.
   */
  name?: string;

  /**
   * Optional additional keyword arguments that provide extended functionality and flexibility
   * in handling the message. These might include additional data fields not covered by the standard properties.
   */
  additionalKwargs?: {
    [key: string]: unknown;
  };
}

/**
 * An abstract base class for messages, implementing the BaseMessageFields interface and extending Serializable for data persistence.
 * BaseMessage provides foundational attributes and methods for message handling, serving as a blueprint for more specific message types.
 */
export abstract class BaseMessage
  extends Serializable
  implements BaseMessageFields
{
  _namespace: string[] = ['events', 'input', 'load', 'msgs', this._role()];

  /**
   * The main content of the message. It can be a string or a more complex structure
   * represented by an object with key-value pairs.
   */
  content: ContentLike | ContentLike[];

  /**
   * An optional name for the message, which could be used for identifying or categorizing the message.
   */
  name?: string;

  /**
   * Optional additional keyword arguments that provide extended functionality and flexibility
   * in handling the message. These might include additional data fields not covered by the standard properties.
   */
  additionalKwargs?: NonNullable<BaseMessageFields['additionalKwargs']>;

  /**
   * Abstract method to define the role of the message, which must be implemented by derived classes.
   * @returns The role of the message as a string.
   */
  abstract _role(): MessageRole;

  /**
   * Constructs a new instance of BaseMessage, initializing with the provided fields.
   * @param fields Either a string or an object conforming to BaseMessageFields to initialize the message content.
   */
  constructor(fields: string | BaseMessageFields) {
    if (typeof fields === 'string') {
      fields = { content: fields };
    }
    super(fields);

    this.name = fields.name;
    this.content = fields.content;
    this.additionalKwargs = fields.additionalKwargs;
  }

  /**
   * Serializes the message to a structured format that includes the role and the JSON-converted content.
   * @returns An object representing the serialized state of the message.
   */
  toSerialized(): SerializedMessage {
    return {
      role: this._role(),
      json: (this.toJSON() as SerializedConstructor)
        ._kwargs as object as SerializedMessageData,
    };
  }

  /**
   * Coerce the message content to boolean.
   *
   * Usecases if the message content is coerceable:
   * - if content equals to either "true" or "false", return corresponding boolean;
   * - `true` if content length larger than 0, otherwise return `false`;
   * - `true` if content is not string type;
   * - if content is array, return `true` if all entries follows the previous three usecases, otherwise return `false`.
   *
   * @returns boolean if coerceable, otherwise return undefined.
   */
  coerceToBoolean(): boolean | undefined {
    const coerceContentLikeToBoolean = (contentLike: ContentLike): boolean => {
      if (typeof contentLike === 'string') {
        return contentLike.length > 0 && contentLike.toLowerCase() !== 'false';
      }

      return true;
    };

    if (Array.isArray(this.content)) {
      return (
        this.content.length > 0 &&
        this.content.every((c) => coerceContentLikeToBoolean(c))
      );
    }

    return coerceContentLikeToBoolean(this.content);
  }

  /**
   * Abstract method to concatenate this message with another message, producing a new BaseMessage instance.
   *
   * @param message The message to concatenate with this instance.
   * @returns A new instance of BaseMessage resulting from the concatenation.
   */
  abstract concat(message: BaseMessage): BaseMessage;

  /**
   * Internal method for merging two message conents.
   *
   * @param left left message content.
   * @param right right message content.
   * @returns merged message content.
   * @internal
   */
  static _mergeContent(
    left: NonNullable<BaseMessageFields['content']>,
    right: NonNullable<BaseMessageFields['content']>
  ): NonNullable<BaseMessageFields['content']> {
    if (!Array.isArray(left) && !Array.isArray(right)) {
      if (typeof left === 'string' && typeof right === 'string') {
        return left + right;
      }

      if (typeof left === 'object' && typeof right === 'object') {
        return {
          ...left,
          ...right,
        };
      }

      throw new Error(
        'Message cannot be merged. Content should follow the same type.'
      );
    }

    if (!Array.isArray(left) && Array.isArray(right)) {
      return [left, ...right];
    }

    if (Array.isArray(left) && !Array.isArray(right)) {
      return [...left, right];
    }

    if (Array.isArray(left) && Array.isArray(right)) {
      return [...left, ...right];
    }

    throw new Error(
      'Message cannot be merged. Content should follow the same type.'
    );
  }

  /**
   * Internal method for merging two additional keyword arguments.
   *
   * @param left left additional keyword arguments.
   * @param right right additional keyword arguments.
   * @returns merged additional keyword arguments.
   * @internal
   */
  static _mergeAdditionalKwargs(
    left: NonNullable<BaseMessageFields['additionalKwargs']>,
    right: NonNullable<BaseMessageFields['additionalKwargs']>
  ): NonNullable<BaseMessageFields['additionalKwargs']> {
    const additionalKwargs = { ...left };
    const newKwargs = { ...right };

    for (const [k, v] of Object.entries(newKwargs)) {
      if (typeof additionalKwargs[k] !== typeof v) {
        throw new Error(
          `key ${k} in additionalKwargs but values do not match types.`
        );
      } else if (additionalKwargs[k] === undefined) {
        additionalKwargs[k] = v;
      } else if (typeof additionalKwargs[k] === 'string') {
        additionalKwargs[k] = (additionalKwargs[k] as string) + v;
      } else if (
        !Array.isArray(additionalKwargs[k]) &&
        typeof additionalKwargs[k] === 'object'
      ) {
        additionalKwargs[k] = this._mergeAdditionalKwargs(
          additionalKwargs[k] as NonNullable<
            BaseMessageFields['additionalKwargs']
          >,
          v as NonNullable<BaseMessageFields['additionalKwargs']>
        );
      } else {
        throw new Error(
          `key ${k} already in additionalKwargs but failed to merge.`
        );
      }
    }

    return additionalKwargs;
  }

  /**
   * Check if two messages are strictly equal.
   *
   * @param message1 message object.
   * @param message2 message object.
   * @returns true if strictly equal.
   */
  static isEqualMessage(message1: BaseMessage, message2: BaseMessage) {
    return isDeepEqual(message1.toSerialized(), message2.toSerialized());
  }

  /**
   * Check if two message arrays are strictly equal.
   *
   * @param messageArray1 message object array.
   * @param messageArray2 message object array.
   * @returns true if strictly equal.
   */
  static isEqualMessageArray(
    messageArray1: BaseMessage[],
    messageArray2: BaseMessage[]
  ) {
    if (messageArray1.length !== messageArray2.length) {
      return false;
    }

    for (let i = 0; i < messageArray1.length; i++) {
      if (!this.isEqualMessage(messageArray1[i], messageArray2[i])) {
        return false;
      }
    }

    return true;
  }
}
