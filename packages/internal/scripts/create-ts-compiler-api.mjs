import path from "path";
import { IndentationText, Project, StructureKind, VariableDeclarationKind } from "ts-morph";
import { getCompilerVersions } from "./get-ts-versions.mjs";
import { mkdir, createFile } from "./utils.mjs";

const API_DIR = './src/compiler/resources/api';
const VERSION_FILE_PATH = path.resolve(API_DIR, 'versions.ts');
const IMPORT_FILE_PATH = path.resolve(API_DIR, 'imports.ts');

/**
 * @param {string} filePath
 * @param {{ version: string; name: string }[]} versions
 */
const generateCompilerVersionAPI = (filePath, versions) => {
  const project = new Project({
    manipulationSettings: {
      indentationText: IndentationText.TwoSpaces,
    },
  });

  const file = project.addSourceFileAtPath(filePath);

  // clean the file
  file.removeText();

  file.addStatements([
    (writer) => {
      writer
        .writeLine('// This file is generated by `scripts/create-ts-compiler-api.mjs`. DO NOT edit manually.')
        .blankLine();
    },
    {
      kind: StructureKind.TypeAlias,
      isExported: true,
      name: "CompilerPackageNames",
      type: versions.map((v) => `"${v.name}"`).join(" | "),
    },
    {
      kind: StructureKind.TypeAlias,
      isExported: true,
      name: "CompilerVersions",
      type: versions.map((v) => `"${v.version}"`).join(" | "),
    },
    {
      kind: StructureKind.VariableStatement,
      isExported: true,
      declarationKind: VariableDeclarationKind.Const,
      declarations: [{
        name: "compilerVersionCollection",
        initializer: (writer) => {
          writer.write("[").newLine();
          writer.indent(() => {
            for (let i = 0; i < versions.length; i ++) {
              const version = versions[i];
              writer.write(`{ version: "${version.version}", packageName: "${version.name}" }`);
              if (i < versions.length - 1) {
                writer.write(".");
              }
              writer.newLine();
            }
          });
          writer.write("]");
        },
        type: "{ version: CompilerVersions; packageName: CompilerPackageNames; }[]",
      }]
    }
  ]);

  file.saveSync();
}

/**
 * @param {string} filePath
 * @param {{ version: string; name: string }[]} versions
 */
const generateCompilerImports = (filePath, versions) => {
  const project = new Project({
    manipulationSettings: {
      indentationText: IndentationText.TwoSpaces
    },
  });

  const file = project.addSourceFileAtPath(filePath);

  // clean the file
  file.removeText();

  file.addStatements([
    (writer) => {
      writer
        .writeLine('// This file is generated by `scripts/create-ts-compiler-api.mjs`. DO NOT edit manually.')
        .blankLine();
    },
    {
      kind: StructureKind.ImportDeclaration,
      namedImports: ["CompilerPackageNames", "CompilerVersions"],
      moduleSpecifier: path.format({
        ...path.parse(relativeWithDot(API_DIR, VERSION_FILE_PATH)),
        base: undefined,
        ext: undefined
      }),
    },
    {
      kind: StructureKind.Function,
      isExported: true,
      isAsync: true,
      name: "importCompilerAPI",
      parameters: [{ name: "packageName", type: "CompilerPackageNames" }],
      statements: (writer) => {
        writer.write("switch (packageName)").block(() => {
          for (const version of versions) {
            writer.writeLine(`case "${version.name}":`);
            writer.indent(() => {
              writer.writeLine(`return await import("${version.name}");`);
            });
          }
          writer.writeLine(`default:`);
          writer.indent(() => {
            writer.writeLine(
              "throw new Error(`no valid version in package: ${packageName}`);",
            );
          });
        });
      },
    },
    {
      kind: StructureKind.Function,
      isExported: true,
      isAsync: true,
      name: "importLibFiles",
      parameters: [{ name: "packageName", type: "CompilerPackageNames" }],
      statements: (writer) => {
        writer.write("switch (packageName)").block(() => {
          for (const version of versions) {
            writer.writeLine(`case "${version.name}":`);
            writer.indent(() => {
              writer.writeLine(
                `return await import("../libFiles/${version.name}/index.js");`
              );
            });
          }
          writer.writeLine(`default:`);
          writer.indent(() => {
            writer.writeLine(
              "throw new Error(`no valid version in package: ${packageName}`);",
            );
          });
        });
      },
    }
  ]);

  file.saveSync();
};

/**
 * @param {string} from
 * @param {string} to
 * @returns {string}
 */
function relativeWithDot(from, to) {
  const relativePath = path.relative(from, to);
  return relativePath.startsWith('./') || relativePath.startsWith('../')
    ? relativePath
    : `./${relativePath}`;
}

mkdir(API_DIR);
createFile(VERSION_FILE_PATH);
createFile(IMPORT_FILE_PATH);

const versions = getCompilerVersions();
generateCompilerVersionAPI(VERSION_FILE_PATH, versions);
generateCompilerImports(IMPORT_FILE_PATH, versions);
